/*
 * DSDatablock.h
 *
 *  Created on: Jan 4, 2018
 *      Author: marvin
 *
 *  Arguably the most important class of the entire Plugin
 *  A Datablock is basicly a very flexible Material whos behaviour almost
 *  entirely depends on a set of Resources that define the kind of Object it is
 *
 *	Basicly
 *
 *	Datablock==Material
 *
 *  Resources
 *  =========
 *
 *  Resources are a type of Object that controls the Behaviour of the Datablock
 *
 *  Some Resource Types
 *
 *  - Value		Manages one or a set of floating point or integer values, such as Matrices, Vectors, Arrays or Singlefloats (Can be changed during runtime)
 *  - Texture	Manages one or a set of Textures as well as some shadercode and values for acessing them inside the shader (Can be changed during runtime)
 *  - Piece		Contains a piece of Procedurally generated shadercode
 *  - Property	Contains an Integer Based Setting for the Shader
 *
 *  Special Resources
 *
 *  - AutoVals 					are special Values that can change their Values automaticly based on predefined behaviours (Timers, Event Listeners, etc)
 *  - PassBufferDefaultVal		Is a special AutoVal that contains the default Values for the Pass Buffer, which also uses Resources to mange its Data
 *  - Light AutoVal				Is an AutoVal used by Light Materials to Sync their shaderdata (Light Color, Direction, Specular, etc) with the actual Ogre Light objects
 *
 *  Using a set of such objects, pretty complex Materials can be created.
 *
 *	Resources belonging to a certain Datablock are called "local Resources"
 *
 *  Assembly
 *  ========
 *
 *  Once the Datablock has been fully assembled and all Resources are assembled, no Resources can be added or removed anymore
 *  Values or Texture can still be changed however. For example, a game could change the texture of a button once the player has
 *  pressed it or changed its color.
 *  Shadercode however cannot be changed anymore. After the Shader has compiled, the datablock is locked.
 *
 *  Lifecycle
 *  =========
 *
 *  After the call of the constructor from HLMS_DS::createDatablockImpl an empty Datablock is created.
 *  Should the Datablock be compiled after this, it will only display a white Surface, without glow or specularity.
 *  A random Color is set randomly, called the IDColor, which can be used to identfy the Datablock visually from a shader,
 *  and to see which objects have the same color.
 *
 *  Now it is filled with Resources by, for example, A Parser, which will now fill it with Resource objects.
 *  After that is done, the shader will be locked and later compiled.
 *
 *  Before the first frame, it will upload all of its Necessary Values generated by Resources, aswell as the IDColor to the GPU
 *  and set its own status to clean, to indicate that its own Values and those on the CPU are synced and don't need to be uploaded
 *  the next frame.
 *
 *  However, should the user change a Value manually, or should the Datablock contain an AutoVal that requires reupload
 *  it will be set to dirty again.
 *
 *  Some AutoVals contain values that require reupload every Frame, so those will cause the Datablock to be perpetually dirty.
 *
 *  Should the Datablock be deleted, it will delete all its Resources (No Resource is ever shared with another Datablock, even if they point to the same Texture).
 *
 *
 *  Shader
 *  ======
 *
 *  The main Source of Shader Code are the contents of Media/Hlms/DS and is created by setting the right Properties to create specific Materials.
 *  The User can of course extend that folder, but it is also possible to extend the Shader functionality by creating ShaderPieces on the fly.
 *
 *
 */

#ifndef SRC_DS_DATABLOCK_DSDATABLOCK_H_
#define SRC_DS_DATABLOCK_DSDATABLOCK_H_
#include "Ogre.h"
#include "OgreHlmsDatablock.h"
#include <OgreHlmsTextureManager.h>
#include <OgreConstBufferPool.h>
#include <OgreHeaderPrefix.h>
#include "../Modules/ModuleReference.h"
#include "../Modules/Resources/DSResource.h"

namespace Ogre {
class HlmsDS;
class Parser;
class DSDatablock: public Ogre::HlmsDatablock, public ModuleReference{
	DSResList mRes;

	//To easily identfiy idndividual datablocks and to avoid empty MaterialBuffers (Not allowed by OpenGL)
	Ogre::Vector4 mIDColor;

	//Sets of the Variable is currently locked, if true it will allow for Resources to be added
	bool mSafeForRewrite=true;
	//Is the Datablock synced with the GPU?
	bool mClean=false;
	//Can we upload Data at the Moment?
	bool mUpdateAllowed=true;
	//Used to give local Resources unique ID's need for shader code generation
	int mResourceNumber=1;


	//Last Parser to edit this Datablock (Usually its only one)
	Parser * mLastParser=NULL;
	//Parent HLMS
	HlmsDS * mCreator=NULL;

	//GPU Buffer to upload the the Resources to
	ConstBufferPacked* mMaterialBuffer=NULL;


	//Initialize the MaterialBuffer using the static sizes of the Resources
	void createMaterialBuffer();
	//Get Amount of Textures used by main texture Array for Datablock
	int GetTexArraySize();
public:
	DSDatablock(IdString name, HlmsDS *creator,
			const HlmsMacroblock *macroblock, const HlmsBlendblock *blendblock,
			const HlmsParamVec &params);


	//Assembly of the Datablock using a Parser
	void initalize(Parser * parser);

	//Check if upload is necessary and possible and sync the Datablock to the GPU
	void upload();

	//Mark as desynchronized
	void soil();
	//Mark as synchronized
	void clean();

	//Generate a list of needed Properties from the Resources and the Datablock.
	DSResource::PropertyList genProperties();
	//Generate a list of ShaderPieces that are generatet by the Resources.
	std::map<IdString,String> genPieces();
	//generate the Texture Buffer which are used to keep track of the Textures generated by Resources
	DSResource::TextureRef::TextureBuffList genTextureBufs();

	//add a new Resource (Not possible after locked)
	void addResource(DSResource *);
	//Get Size of the Buffer necessary for the Material
	int getBufferSize();
	//Get of the Buffer necessary for the Material
	ConstBufferPacked * getMaterialBuffer();
	//Destroy all Resources and clean up
	virtual ~DSDatablock();
	//Get IDColor
	const Ogre::Vector4& getIdColor() const;
	//Set new IDColor
	void setIdColor(const Ogre::Vector4& idColor);
	//Generate a new ID For the Resource
	int newIncRSNum();
	//Is it currently synced?
	bool isClean() const;
};

} /* namespace Ogre */

#endif /* SRC_DS_DATABLOCK_DSDATABLOCK_H_ */
