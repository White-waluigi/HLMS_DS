/*
 * DSResource.cpp
 *
 *  Created on: Jan 21, 2018
 *      Author: marvin
 */

#include "DSResource.h"
#include "../../OgreHlmsDS.h"
namespace Ogre {



DSResource::DSResource(reflist l): DSModule(l) {

	//get parent datablock
	DSDatablock * ParentDB= dynamic_cast<DSDatablock *>( getReference("datablock"));
	//Get parent HLMS
	this->mParentHLMS=dynamic_cast<HlmsDS*> ( getReference("hlms"));
	//Get Mandatory Init (used for name here)
	MandatoryInit * mi=dynamic_cast<MandatoryInit *> ( getReference("mandatory"));

	//Get assigned a new Resource Number, if used by Datablock
	if(ParentDB!=NULL){
		this->mResourceNum=ParentDB->newIncRSNum();
	}
	//Name cannot be empty
	if(mi->mName.compare("")==0){
		OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS,"Name for Resource cannot be empty","DSResource::DSResource(reflist l): DSModule(l) {");
	}

	this->mName= mi->mName;


}

Ogre::String DSResource::getName() {
	return this->mName;
}

DSResource::~DSResource() {
	//todo cleanup
}

void DSResource::init() {
	//Not necessary
}


refreq * Ogre::DSResource::getRequiredRefs() {
	refreq *r=DSModule::getRequiredRefs();

	//Backlink to the Hlms System
	r->push_back("hlms");
	//Mandatory init data needed for working Resource
	r->push_back("mandatory");
	return r;
}

bool Ogre::DSResource::isClean() {
	return mClean;
}

void Ogre::DSResource::soil() {
	mClean=false;
}

void Ogre::DSResource::clean() {
	mClean=true;
}
void Ogre::DSResource::checkLock() {
	//Cannot do certain changes to locked Resources
	if(this->locked()){
		OGRE_EXCEPT(Exception::ERR_INVALID_STATE,"Cannot edit Attributes of Resources which would change its Buffersize after they have been bound to a Datablock","void Ogre::DSResource::checkLock() {");
	}
}
bool Ogre::DSResource::locked() {
	return mLocked;
}
void Ogre::DSResource::lock() {
	mLocked=true;
}
String Ogre::DSResource::ShaderPiece::Merge(String a,String l) {

	//Merge conflice solutions for ShaderPices (what to do if 2 ShaderPieces have the same name)
	if(this->mConflict==ShaderPiece::APPEND){
		//Simply add to the end
		return a+this->mCode[l];
	}else if(this->mConflict==ShaderPiece::IGNORE){
		//Simply replace old code
		return a;
	}else if(this->mConflict==ShaderPiece::INSERT){
		//Insert new Code at certain position
		return StringUtil::replaceAll(a,"${@REPLACE}",this->mCode[l]);
	}else if(this->mConflict==ShaderPiece::PREPEND){
		//Put at the end
		return this->mCode[l]+a;
	}
		//Otherwise just ignore
		return this->mCode[l];
}

Ogre::DSResource::MandatoryInit::MandatoryInit(Ogre::String name) {
	this->mName=name;

}

String Ogre::DSResource::ShaderPiece::clean(String allocator) {
	//Make sure no Replacement tags are left before insertion into shader
	return StringUtil::replaceAll(allocator,"${@REPLACE}","");
}

std::map<IdString, String> Ogre::DSResource::ShaderPiece::GetPieces(shaderList * pb,String lang) {


	//Merge all ShaderPieces generated by the the Resource
	std::map<IdString, String> res;
	for(shaderList::iterator it=pb->begin(); it != pb->end(); ++it){

		//If shader languague not used by shadercode, simply try to return the glsl code, since its the most likely to work
		if(res.find((*it)->mShaderKeyWord)!=res.end()){
			res[(*it)->mShaderKeyWord]=(*it)->Merge(res[(*it)->mShaderKeyWord],lang);
		}else{
			res[(*it)->mShaderKeyWord]=(*it)->mCode["glsl"];
		}
	}
	//Clean up the shaderpieces (Remove Tags)
	for(std::map<IdString, String>::iterator it=res.begin(); it != res.end(); ++it){
		res[it->first]=clean(it->second);
	}
	return res;
}

Ogre::DSResource::ShaderPiece::shaderList Ogre::DSResource::genShaderPieces() {
	//By default empty shader Pieces
	return ShaderPiece::shaderList();
}

Ogre::DSResource::PropertyList Ogre::DSResource::genProperties() {
	//By default empty properties
	return PropertyList();
}

Ogre::DSResource::TextureRef::TextureBuffList Ogre::DSResource::genTextureBuf() {
	//By default empty texture array
	return TextureRef::TextureBuffList();
}

int DSResource::getRSNum() {
	return this->mResourceNum;
}


} /* namespace Ogre */
